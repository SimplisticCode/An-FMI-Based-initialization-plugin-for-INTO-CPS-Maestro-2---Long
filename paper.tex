% This is samplepaper.tex, a sample chapter demonstrating the
% LLNCS macro package for Springer Computer Science proceedings;
% Version 2.20 of 2017/10/04
%
\documentclass[runningheads]{llncs}

\usepackage{graphicx}
\usepackage{ae,aecompl}
\usepackage[utf8]{inputenc}
\usepackage[english]{babel}
\usepackage{verbatim}
\usepackage{graphicx}
\usepackage{amsfonts}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{stmaryrd}
\usepackage{amstext}
\usepackage{bm} 
\let\proof\relax
\let\endproof\relax
\usepackage{amsthm}
\usepackage{siunitx}
\usepackage{mathrsfs}
\usepackage{wrapfig}
\usepackage{minted}
\usepackage{algorithm}
\usepackage{algpseudocode}
\usepackage{semantic}
\usepackage[dvipsnames]{xcolor}
\usepackage{paralist}
\usepackage{cite}
\usepackage{url}
\usepackage{todonotes}
% Used for displaying a sample figure. If possible, figure files should
% be included in EPS format.
%
% If you use the hyperref package, please uncomment the following line
% to display URLs in blue roman font according to Springer's eBook style:
% \renewcommand\UrlFont{\color{blue}\rmfamily}
\input{commands}

\begin{document}
%
\title{An FMI-Based Initialization Plugin for INTO-CPS Maestro 2}
%
%\titlerunning{Abbreviated paper title}
% If the paper title is too long for the running head, you can set
% an abbreviated paper title here
%
\author{Simon Thrane Hansen\inst{1} \and
Casper Thule\inst{1} \and
Claudio Gomes \inst{1}}
%
\authorrunning{S. Thrane and C. Thule}
% First names are abbreviated in the running head.
% If there are more than two authors, 'et al.' is used.
%
\institute{DIGIT, Department of Engineering, Aarhus University, \email{\{sth, casper.thule\}@eng.au.dk\}}}
%
\maketitle              % typeset the header of the contribution
%

\input{abstract.tex}

\input{introduction.tex}


\section{Background}\label{sc:background}
In this section, we provide a formalization of FMI co-simulation and a short background on INTO-CPS Maestro 2.

\subsection{FMU definitions}
To describe the formalization of FMUs, the vocabulary from Gomes et al\cite{gomes_lucio_vangheluwe_2019, Gomes2018} is adopted. The main definitions of relevance to this paper will be presented, but readers are referred to the original publications for more information. This paper is only concerned with the initialization-phase of a co-simulation. All information about the time of an FMU and master algorithms is of no relevance and will not be discussed in more detail. 
The formalization from Gomes et al. is also extended with some new definitions regarding algrebraic loops, and 
\begin{definition}[FMU]\label{def:fmu}
  An FMU with identifier $c$ is represented by the tuple   
  $$\tuple{\stateset{c}, \inputs{c}, \outputs{c}, \fset{c}, \fget{c}},$$
  where:
  \begin{inparadesc}
    \item $\stateset{c}$ represents the state space;
    \item $\inputs{c}$ and $\outputs{c}$ the set of input and output variables, respectively;
    \item $\fset{c} : \stateset{c} \times \inputs{c} \times \values \to \stateset{c}$ and $\fget{c}: \stateset{c} \times \outputs{c} \to \values$ are functions to set the inputs and get the outputs, respectively (we abstract the set of values that each input/output variable can take as $\values$).
  \end{inparadesc}
\end{definition}

\begin{definition}[Scenario]\label{def:cosim_scenario}
  A scenario is a structure $\tuple{\fmus, \coupling}$ where each identifier $c \in \fmus$ is associated with an FMU, as defined in \ref{def:fmu}, and $\coupling(u)=y$ means that the output $y$ is connected to input $u$.
  Let $\allinputs = \bigcup_{c \in \fmus} \inputs{c}$ and $\alloutputs = \bigcup_{c \in \fmus} \outputs{c}$, then $\coupling : \allinputs \to \alloutputs$.
\end{definition}

The following definitions correspond to the operations that are permitted in the initialization phase of a co-simulation.

\begin{definition}[Step]\label{def:cosim_step}
  Given a scenario $\tuple{\fmus, \coupling}$, a co-simulation step, or just step, is a finite ordered sequence of FMU function calls $\sequence{\functioncall_i}_{i \in \setnat} = \functioncall_0, \functioncall_1, \ldots$ with
  $\functioncall_i \in \allfunctioncalls = \bigcup_{c \in \fmus} \set{\fset{c},\fget{c}},$
  and $i$ denoting the order of the function call.
\end{definition}

\begin{definition}[Initialization]\label{def:initialization}
  Given a scenario $\tuple{\fmus, \coupling}$, we define the initialization procedure $\sequence{\initcall_i}_{i \in \setnat}$ in the same way as a step, with $\initcall_i \in \allfunctioncalls$.
\end{definition}

\begin{definition}[Feed-through]\label{def:feedthrough}
  The input $\inputvar{c} \in \inputs{c}$ feeds through to output $\outputvar{c} \in \outputs{c}$, that is, $(\inputvar{c},\outputvar{c}) \in \feedthrough{c}$, when there exists $v_1, v_2 \in \values$ and $\state{c} \in \stateset{c}$, such that
  $
  \fget{c} (\fset{c}(\state{c}, \inputvar{c}, v_1), \outputvar{c}) \neq \fget{c} (\fset{c}(\state{c}, \inputvar{c}, v_2), \outputvar{c}).
  $
\end{definition}

\begin{figure}
    \centering
    \includegraphics{images/FMU_legendpdf.pdf}
    \caption{FMU representation}
    \label{fig:fmu_legend}
\end{figure}

An FMU can visually be displayed as in Figure \ref{fig:fmu_legend} where a simple co-simulation scenario is shown.

\begin{definition}[Output Computation]\label{def:getout}
The $\fget{c}(\dontcare, \outputvar{c})$ represents the calculation of output $\outputvar{c}$ of $c \in \fmus$. Given a co-simulation state, it checks whether all inputs that feed-through to $\outputvar{c}$ are defined.
\end{definition}

\begin{definition}[Input Computation]\label{def:setin}
The $\fset{c}(\dontcare, \inputvar{c}, \inputV)$ represents the setting of input $\inputvar{c}$  of $c \in \fmus$. Given a co-simulation state, it checks whether all outputs connected to $\inputvar{c}$ are defined.
\end{definition}

\begin{definition}[Interconnected variable]
An interconnected variable v of a co-simulation scenario $\tuple{\fmus, \coupling}$ is defined as $v \in \allinputs \cup \alloutputs$, then $\coupling : \allinputs \to \alloutputs$.
\end{definition}

\begin{definition}[Algebraic loops]\todo{Create this definition}
An interconnected variable v of a co-simulation scenario $\tuple{\fmus, \coupling}$ is defined as $v \in \allinputs \cup \alloutputs$, then $\coupling : \allinputs \to \alloutputs$.
\end{definition}



\begin{definition}[Fixed point iteration]\todo{Create this definition}
An interconnected variable v of a co-simulation scenario $\tuple{\fmus, \coupling}$ is defined as $v \in \allinputs \cup \alloutputs$, then $\coupling : \allinputs \to \alloutputs$.
\end{definition}

\subsection{INTO-CPS Maestro 2}\todo{We can have some more in this section - potentially half a page?}
INTO-CPS Maestro 2\footnote{currently in alpha \url{https://github.com/INTO-CPS-Association/maestro/tree/2.0.0-alpha}}\cite{thule_maestro2_2019} is an FMI-based co-simulation framework set to supersede Maestro\cite{Maestro}. The philosophy of the framework is to apply plugins to generate co-simulation specifications expressed in the domain specific language called Maestro Base Language (MaBL). Such specifications are then interpreted and executed resolving in the execution of a co-simulation.

\section{Generation of an Initialization Order}\label{sc:initilization}
FMI defines certain information about the initialization order described through different states of a co-simulation. The initialization phase covers the two states (in chronological order):
\begin{itemize}
    \item \textit{Instantiated}
    \item \textit{Initialization Mode}
\end{itemize}
In each of the two states, different groups of FMU variables can be assigned a value. The groups are defined by FMI based on predicates on the characteristics of the variables (\textit{causality}, \textit{initial} and \textit{variability}). These predicates have been extracted and used in the implementation. 
An example of a group is the \textit{INI}-group that consists of FMU variables with $initial = exact\, \lor initial = \,approx $  and $variability \neq constant$. All variables of this group should be set in the \textit{Instantiated}-phase of a co-simulation, and since they have no dependencies/connections to other FMU variables, the order is insignificant. However, all variables of each FMU are group together to perform the fewest possible operations in the initialization. The FMI specification does allow multiple variables of a single FMU to be set in parallel.

In the \textit{Initialization Mode} state, the variables of all FMUs should be defined if no circular dependencies exist. 
The variables with \textit{causality = parameter} of each FMU are set first, and the order of which they are set is again insignificant as they are independent.
Afterwards the interconnected variables should be defined, but as stated by the definitions \ref{def:feedthrough}, \ref{def:getout} and \ref{def:setin} the operations \textit{get} and \textit{set} \textbf{require} a specific initialization order. And an algebraic loop in a co-simulation scenario places even more criteria on the initialization order.


\subsection{Method}
The approach to calculate the initialization order of the interconnected FMU variables are based on the the method proposed in Gomes et al. \cite{Gomes2019b, BromanCompositionCo-Simulation}, but the approach used here has been extended with the ability to handle algebraic loops. 

\subsubsection{Structure of the graph}
The initialization algorithm starts by building a directed graph of the dependency among the interconnected variables of the FMUs, The graph is constructed based on the interconnected variables and internal connections (feed-through). Each interconnected variable in the system represents a node, and the edges are based on these connections. The edges of this graph represent precedence constraints based on the algebraic dependencies of the interconnected variables. Please see definition \ref{def:initialization_graph} for a formal definition of the graph.

\begin{definition}[Initialization Graph]\label{def:initialization_graph}
  Given a co-simulation scenario $\tuple{\fmus, \coupling}$, and a set of feed-through dependencies $\bigcup_{c \in \fmus} \set{\feedthrough{c}}$, we define the Initialization Graph where each node represents a port $\outputvar{c} \in \outputs{c}$ or $\inputvar{c} \in \inputs{c}$ of some fmu $c \in \fmus$. The edges are created according to the following rules:
  \begin{compactenum}
    \item For each $c \in \fmus$ and $\inputvar{c} \in \inputs{c}$, if $\coupling(\inputvar{c}) = \outputvar{d}$, add an edge $\outputvar{d} -> \inputvar{c}$.
    \item For each $c \in \fmus$ and $(\inputvar{c},\outputvar{c}) \in \feedthrough{c}$, add an edge $\inputvar{c} -> \outputvar{c}$.
  \end{compactenum}
\end{definition}

\subsubsection{Calculation of a initialization order}
The topological ordering of a the graph defined in definition \ref{def:initialization_graph} is used a as the initialization order of the interconnected FMU variables. The elements of the topological order is the strongly connected components of the graphs. The strongly connected components are potentially algebraic loops of the system. The algebraic loops is easily identified as the strongly connected components containing more than a single element. The single element members of the topological order is normally interconnected FMU variables, whose value should only be calculated once during the initialization. \\
The calculation of an initialization order is performed in linear time based on the number of both external and internal connections using Tarjan's algortihm \cite{tarjan_1972}. Tarjan's algorithm is both detecting the strongly connected components of a graph and calculating the topological ordering.

\todo{Come with an example using a graph with loops}

\subsubsection{Handling of algebraic loops}
As described earlier it is important to handle the algebraic loops by a special strategy since they otherwise would invalidate the result of the co-simulation. The strategy for handling of algebraic loops is to identify and initialize them using a fixed point iteration until the initial value of these converges. The termination of using fixed-point iteration has been proved \todo{Write more}.

This paper's main contribution is to calculate an initialization order of a co-simulation scenario containing algebraic loops. The approach make the circular dependencies between the interconnected converge in the initialization, so the initial values of the interconnected variables in the system being simulated is stable at the time the co-simulation is started.


\noindent As previously stated, a valid initialization order can only be calculated from an Initialization Graph if it does not contain any strongly connected components. This insight can be used to specify for which co-simulation scenarios a correct initialization order can be generated. A valid co-simulation scenario to calculate an initialization order from is defined in definition \ref{def:valid_graph}.

\begin{definition}[Algebraic loop in an Initialization Graph]\label{def:algebraic_loop}
  An algebraic loop in the given a co-simulation scenario $\tuple{\fmus, \coupling}$, and a set of feed-through dependencies $\bigcup_{c \in \fmus} \set{\feedthrough{c}}$ can be found if.\\
  $\exists c \in \fmus : \exists \inputvar{} \in \inputs{c}, \outputvar{} \in \outputs{c}: (\inputvar{},\outputvar{}) \in \feedthrough{c} \land Path(\outputvar{}, \inputvar{})$\\
  Where Path is defined as the transitive closure of $Path = L \cup \bigcup_{c \in \fmus} \set{\feedthrough{c}}$\\
  The algebraic-loops is all \todo{Ask Stefan}
\end{definition}

All co-simulation scenarios satisfying definition \ref{def:algebraic_loop} contains at least one s guaranteed to have a valid initialization order.  

\subsection{Case study}
Claduio writes this -section 
\subsection{Three Tank Example}
The structure of the Initialization Graph will be described using a small example. 
The example is based on three water tanks that are filled and emptied. The first tank is filled from a source with a valve that may be turned on and off. The outflow of the first tank constitutes the inflow of the second, and so forth. A discrete-event controller monitors the level of the third tank and controls a valve to a drain. When the water level of the tank reaches a particular level (defined in the controller), the controller sends a command to the tank to empty using an exit valve. An illustration of the three water tanks can be seen in Figure \ref{fig:watertank}. A diagram of the FMUs showing the interconnections of the FMU variables in the system can be in Figure \ref{fig:watertank}. It should be noted that all internal connections that do not \textit{feed-through} have been omitted to simplify the diagram since they do not influence the initialization order and are not included in the graph defined in definition \ref{def:initialization_graph}. 

\begin{figure}[H]
    \begin{minipage}{0.40\textwidth}
    \centering
        \centering
    \includegraphics[width=1\textwidth]{images/ttwt_overview.pdf}
    \end{minipage}
    \begin{minipage}{0.60\textwidth}
        \centering
    \includegraphics[width=1\textwidth]{images/threetank_FMU.pdf}
    \end{minipage}
    \caption{Three tank case study}
    \label{fig:watertank}
\end{figure}

\noindent A correct initialization order can be calculated since there are no circular dependencies in the system, the Initialization Graph is valid based on definition \ref{def:valid_graph}. The corresponding Initialization Graph of the three tank system can be seen in figure \ref{fig:initilizationGraph}. As it can be seen from the Initialization Graph, it is a disconnected graph meaning there are no limitations on the order of the initialization between the two sub-graphs. Nevertheless, in this case, an optimization of the initialization order can be made, using the fact that the FMI specification allows the set/get variables of the same FMU to be performed in bulk. This optimization can be made by setting the two inputs of \textit{T2} simultaneously (by the same operation). The definition of the optimization can be found in definition \ref{def:optimization}.
It is not challenging to calculate the initialization order in this simple example. However, knowledge about the internal connections of each FMU is needed in order to calculate the initialization order due to \textit{feed-through} in FMU \textit{T2}. The strategy for calculating the initialization order scales to more advanced systems with an arbitrary number of FMUs and interconnected variables. Furthermore, an initialization order can be found as long a the Initialization Graph satisfies the criteria of definition \ref{def:valid_graph}.

\begin{figure}
    \centering
      \includegraphics[width=0.95\textwidth]{images/threetank_initialization.pdf}
    \caption{Initialization Graph of three tank}
  \label{fig:initilizationGraph}
\end{figure}


\begin{definition}[Optimization of a Initialization procedure]\label{def:optimization}
  Given an initialization procedure $\sequence{\initcall_i}_{i \in \setnat}$ with a finite ordered sequence of FMU function calls $\functioncall_i \in \allfunctioncalls = \bigcup_{c \in \fmus} \set{\fset{c},\fget{c}},$ and $i$ denoting the order of the function call. It can be optimized if $\exists \functioncall_i, \functioncall_{i +1} \in \allfunctioncalls : \exists c \in \fmus :(\functioncall_i \in {\fset{c}} \land \functioncall_{i+1} \in {\fset{c}}) \lor (\functioncall_i \in {\fget{c}} \land \functioncall_{i+1} \in {\fget{c}})$
\end{definition}
This optimization uses the fact that the FMI specification allows to multiple \textit{set} or \textit{get} operations of the same FMU to be performed in bulk by grouping them together to a single operation over multiple variables with similar characteristic.
Since an Initialization procedure is defined in the same they as other co-simulation steps the optimization criteria described in definition \ref{def:optimization} is valid for an arbitrary co-simulation step. The only difference between an arbitrary co-simulation step and an initialization procedure is the size of the dependency graph on which the topological ordering is performed. 
The correctness of this optimization can be established by the proof of using the Initialization Graph's topological ordering as the initialization order described by Gomes et al\cite{Gomes2019}. This proof is still valid since this optimization does not change the structure of the Initialization Graph. 
A limitation of using this optimization strategy is that it potentially will not find all valid optimizations of a co-simulation scenario since it works on a specific co-simulation step (a topological order of a graph), which is not necessarily unique for a given co-simulation scenario/graph. To perform all possible optimizations of a co-simulation step, a more advanced optimization strategy should be used, or the optimization should be performed on the set of all valid co-simulation steps.

\section{Realization of a Maestro 2 Plugin}\label{sc:implementation}
This approach has been realized as a Maestro 2 plugin that generates the \textit{Initialization}-phase of a co-simulation specification expressed in MaBL. It calculates the specification based on a list of FMU-components, the simulation scenario as defined in definition \ref{def:cosim_scenario}, and a specific plugin-configuration to let the user supply initial values of FMU variables with $causality=parameter$. The plugin optimizes the initialization order of the initialization by grouping operations that can be executed in \textit{parallel} to take advantage of FMI's ability to set or get multiple variables in bulk from the same FMU. The criteria for this optimization is defined in definition \ref{def:optimization}. 
The developed plugin has been tested on numerous co-simulation examples from the INTO-CPS universe\todo{should I add a footnote} and compared with the existing \textit{Initializer} of Maestro. The plugin has been tested in the whole Maestro 2 pipeline to practically verify that it can be used in a co-simulation where the generated initialization procedure is integrated as a part of a complete co-simulation to verify the initialization procedure's integration with a master algorithm.

\subsection{Topological sorting}
The algorithm for calculating the topological order of the Initialization Graph defined in definition \ref{def:initialization_graph} is Tarjan's algorithm\cite{tarjan_1972}. The algorithm was selected since it solves two of the central issues of the initialization-phase of the co-simulation.
\begin{itemize}
    \item Identifies circular dependencies between interconnected variables (strongly connected components)
    \item Performs a topological sorting of the Initialization Graph
\end{itemize}
The algorithm is furthermore well-established, and there exist formal proofs of its correctness and properties\cite{stefan_merz}. The algorithm is among the best performance graph algorithms to solving the defined task.  

The topological sorting algorithm was implemented in Scala. The choice of Scala is motivated by the relation to JVM and the connection to Slang and the Logika framework\cite{inbook}. The connection to Slang and Logika will be investigated in the future. The Logika framework will be used to formally verify the implementation plugin and be used to explore how the contract-based nature of Slang can be used to obtain more reliable results of co-simulations. The topological sorting returns a topological order of strongly connected components. This order is the order of initialization, where the elements containing more than a single element denotes an algebraic loop that requires a particular initialization strategy. The algebraic loops should be initialized using fixed-point iteration in order to obtain a stable initial value.

\subsection{Verification of the approach}
The realized plugin and the developed approach have been verified in several different ways. Gomes et al. have in \cite{gomes_lucio_vangheluwe_2019} proved the correctness of using the topological order of a dependency graph of the interconnected variables to generate not only the initialization order but also the order for a co-simulation master-algorithm. The purpose of the publication by Gomes et al. is a little different from the one of this paper. Gomes et al. are interested in both generating an initialization and master-algorithm, meaning they also need to focus on the time of each FMU. They also define their graph using methods (Set, Get, doStep) instead of interconnected variables, which is the approach described in this paper. This simplification is valid since this approach only cares about initialization and, therefore, does not need to care about the time of each FMU. This does that we can omit all the $doStep$ nodes and all edges connected to them from the graph by Gomes et al., this approach does, therefore, end up with a subgraph of the graph by Gomes et al. The proof from \cite{gomes_lucio_vangheluwe_2019} can therefore trivial be modified to the graph/approach presented in this paper.

Gomes et al. 's main contribution is an implementation of the FMI specification in Prolog freely available to be used in other projects. The Prolog implementation was used in their research to verify their proposed approach for the generation of co-simulation algorithms. The realization encapsulates all the rules of a valid master-algorithm and an initialization algorithm. As a part of this work, an integration from this plugin has been realized to interact with the Prolog realization. This integration has been realized in order to verify the correctness of the calculated initialization order against an established and recognized method. The integration is based on JIProlog\cite{}, and it is querying the Prolog database with a co-simulation environment and an initialization order. The integration requires substantial mapping of the objects between the Java code of Maestro 2 and the Prolog implementation. Due to the described differences between the two graphs, a mapping from the graph of ports to the graph of operations is needed. This mapping is based on the definitions \ref{def:getout} and \ref{def:setin}.

The Prolog code can generate an initialization order, but this functionality has not been used for several reasons. The main reason for not generating the initialization order using the Prolog code is based on performance considerations. The approach taken in this paper does also identifies the strongly connected components and performs a particular initialization strategy of these.

\section{Related Work}
Prior work \cite{Gomes2019, BromanCompositionCo-Simulation} had been looking into the generation of co-simulation algorithms for both master and initialization algorithms for FMI-based scenarios based on a graph of the operations of a co-simulation step. Gomes and Broman do both present an approach where they use the topological sorting of a dependency graph to establish a correct order in which the operations of a co-simulation step should be performed. 
Gomes et al. \cite{Gomes2019} propose a strategy for the generation of co-simulation algorithms and define the criteria for a correct co-simulation step.  Their work has many similarities with ours. However, their work is not implemented and used in a practical context like ours that has been implemented as a plugin to Maestro 2. Furthermore, the approach taken in this paper is only concerned with the initialization procedure of a co-simulation.

The work by Broman et al. \cite{BromanCompositionCo-Simulation} proposes using the topological sorting of a dependency graph of the interconnected variables to detect algebraic loops and discover the partial order of port-operations. Nevertheless, they specify the requirement for cycle freedom in the dependency graph as a precondition for the generation of a deterministic co-simulation algorithm. It means they refuse all co-simulation scenarios containing algebraic loops. This is a significant difference in our approach. The approach in this paper is more specialized in the sense that it is only considering the initialization of a co-simulation. This focus does that our work do need to include the handling of non-interconnected variables that should be addressed during the initialization of a co-simulation. 

Prior work by Amalio et al. \cite{Amalio2016CheckingCo-simulation} has been investigating how to find and avoid algebraic loops in FMU based co-simulation scenarios by statically checking the SysML CPS architectural design. The publication's purpose is a bit different from ours - to guarantee the absence of algebraic loops in a co-simulation scenario. But their approach of being implemented 
Nevertheless, their approach is only concerned with ensuring the absence of algebraic-loops since their approach is analyzing an architecture design; the calculation of the initialization order is not in scope of their work.



\input{conclusion.tex}
%
% ---- Bibliography ---

\bibliographystyle{splncs04}
\bibliography{gen_bib}


\end{document}
