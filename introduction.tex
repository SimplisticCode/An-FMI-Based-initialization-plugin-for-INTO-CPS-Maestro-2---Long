\section{Introduction}\label{sc:introduction}
Cyber-physical systems (CPS) are becoming ever more sophisticated, while market pressure shortens the available development time. One of the tools used to manage the increasing complexity of such systems is co-simulation since it addresses their various parts of heterogeneous nature. Co-simulation is a technique to combine multiple black-box simulation units to simulate/compute the behavior of the combined models as a discrete trace\cite{Kubler2000}. The simulation units, often developed independently from each other, are coupled using a master algorithm, also often developed independently,
that communicates with each simulation unit via its interface. This interface comprises functions for setting/getting inputs/outputs, and computing the associated model behavior over a given interval of time. \\
The Functional Mock-up Interface (FMI) standard \cite{Blochwitz2012, fmi_2019} is such an interface describing how to communicate with each simulation unit. This interface can be used to connect different simulation units (called Functional Mock-up Units or FMUs) and exchange values between them and make them progress in time. \\
A typical co-simulation consists of three phases: Initialization, simulation, and teardown. This work concentrates on the first of these phases - the initialization phase. FMI specifies criteria for how an FMU shall be initialized. However, the FMI standard is not concerned with how a connected system of multiple FMUs should be correctly initialized as a whole. 
The way a system of multiple FMUs should be initialized and interacted with depends on each FMUs implementation and interconnections to other FMUs \cite{gomes_lucio_vangheluwe_2019}, since these place precedence constraints between the FMU variables. The precedence constraints make specific system configurations and initialization orders of a system invalid due to cyclic dependencies and dependencies among the interconnected variables. An appropriate order of initialization is vital for the correctness of the co-simulation \cite{Thule2018} because it ensures a variable is never read before it is set like the classical \textit{readersâ€“writers problem}. Circular dependencies are important to avoid in a co-simulation scenario since they reduces the ability of a co-simulation to converge \cite{Amalio2016CheckingCo-simulation, BromanCompositionCo-Simulation}.\\

This paper describes an approach for the initialization of an FMI-based co-simulation in linear time of the number of interconnected variables. The approach complies with the semantics of FMI and ensures the absence of cycles in the system. The approach does not put any constraints on choosing a master algorithm that should be used to carry out the simulation. This means that the approach is suitable to combine with well-established master algorithms like Gauss-Seidel and Jacobian \cite{Palensky2017}. The approach has been realized as a plugin to the co-simulation framework called INTO-CPS Maestro 2 (Maestro 2). The realized plugin has been tested for various co-simulation scenarios and compared to an existing \textit{Initializer} that has been validated through academic and industrial applications. Gomes et al. have created a co-simulation algorithm generator and verifier\cite{gomes_lucio_vangheluwe_2019} in Prolog an integration to this realization has been crated as a part of the plugin. This integration is used to verify the calculated initialization order against an already established method for calculating the initialization order.\\

The paper is structured as follows: Section \ref{sc:background} gives a brief background of the formalization of FMUs and Maestro 2. Section \ref{sc:initilization} describes the approach taken to calculate the initialization order. This is followed by section \ref{sc:implementation}, where the realization of the approach is presented. Finally, section \ref{sc:summary} provides concluding remarks and describes future work.