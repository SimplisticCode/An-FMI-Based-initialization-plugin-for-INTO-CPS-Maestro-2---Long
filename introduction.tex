\section{Introduction}\label{sc:introduction}
Cyber-physical systems (CPS) are becoming ever more sophisticated, while market pressure shortens the available development time. One of the tools to manage the increasing complexity of such systems is co-simulation since it tackles their heterogeneous nature. Co-simulation is a technique to combine multiple black-box simulation units to compute the behavior of the combined models as a discrete trace (see, e.g., \cite{Kubler2000, Gomes2018}). The simulation units, often developed independently from each other, are coupled using a master algorithm, also often developed independently, that communicates with each simulation unit via its interface. This interface comprises functions for setting/getting inputs/outputs, and computing the associated model behavior over a given time interval.
The Functional Mock-up Interface (FMI) standard \cite{Blochwitz2012, fmi_2019} is such an interface prescribing how to communicate with each simulation unit. The interface is used to connect different simulation units, called Functional Mock-up Units (FMUs), exchange values between them, and make them progress in time.

A typical co-simulation consists of three phases: initialization, simulation, and teardown \cite{Thule2019b}. This work concentrates on the first. The FMI specifies criteria for how a single FMU shall be initialized. However, the FMI is not concerned with how a connected system of multiple FMUs is initialized correctly as a whole.

The way a system of multiple FMUs should be initialized and interacted with depends on each FMUs implementation and interconnections to other FMUs \cite{gomes_lucio_vangheluwe_2019}, since these place precedence constraints between the FMU variables. These constraints can introduce algebraic loops, which places particular requirements on the initialization order to calculate the initial values of the variables in the algebraic loop\cite{Bastian2011a}. Algebraic loops occur whenever an interconnected FMU variable indirectly depends on itself. Not solving an algebraic loop can lead to a prohibitively high error in the co-simulation result \cite{Arnold2014}, and invalid results, as shown in \cref{sec:case_study}. For variables that do not belong in an algebraic loop, the initialization has to ensure that a variable is never read before it is set like the classical \textit{readersâ€“writers problem}. For variable within an algebraic loop, the initialization has to make sure that all initial values have converged to a fixed point.

Other approaches for the generation of co-simulation algorithms have avoided co-simulation scenarios containing algebraic loops since their presence reduces the chance of obtaining a deterministic co-simulation result\cite{Amalio2016CheckingCo-simulation, BromanCompositionCo-Simulation, Gomes2019c}. This choice is driven by the fact that not all co-simulation scenarios containing algebraic loops are valid since those algebraic loops never converge, or might converge to unexpected solutions. However, as shown in \cref{sec:case_study}, algebraic loops can be essential to obtaining valid simulation results, and a well-established co-simulation framework should be able to handle these scenarios. 

\textit{Contribution:} This paper describes an approach for calculating the initialization order of an FMI-based co-simulation in linear time of the number of interconnected variables, even when algebraic loops are present.
% The approach complies with the semantics of FMI and support the initialization of algebraic loops between interconnected FMU variables and identifies divergence in a co-simulation scenario. 
The approach does not put any constraints on choosing a master algorithm that should be used to carry out the simulation. 
This means that the approach is suitable to combine with well-established master algorithms like Gauss-Seidel and Jacobian \cite{Palensky2017}. 
\claudio{Maybe move the above sentence to the conclusion as it's kind of redundant with the previous sentence, and seems to a conclusion of this approach.}
The approach is realized as a plugin to the co-simulation framework called INTO-CPS Maestro 2 (Maestro 2), introduced in \cite{Thule2019b}.
The realized plugin has been tested for various co-simulation scenarios and compared to an existing approach that has been validated through academic and industrial applications. 
Furthermore, the calculated initialization order is systematically verified by the semantics of co-simulation introduced in \cite{gomes_lucio_vangheluwe_2019,Gomes2019c}. \\
\claudio{Simon, can you please remove the double slashes (like the one right before this comment) from the end of sentences and paragraphs? It's bad practice to force Latex to make new lines. Also, you don't want to worry about that... latex usually does a good job at laying out the text for you.}

\textit{Structure:} The paper is structured as follows: Section \ref{sc:background} gives a brief background of the formalization of FMUs and Maestro 2. Section \ref{sc:initilization} describes the approach taken to calculate the initialization order. It is followed by section \ref{sc:implementation}, where the realization of the approach is presented. Finally, section \ref{sc:summary} provides concluding remarks and describes future work.
\claudio{Simon, please make sure that the references are according to what the template suggests. Some templates ask references like \emph{Section~\ref{sc:summary}} and others ask for \emph{Sect.~\ref{sc:summary}}, or \emph{section~\ref{sc:summary}}, or \emph{sect.~\ref{sc:summary}}. The package cleveref allows you to configure how you want references to be displayed (see the package documentation) and make this uniform throughout all document. The same comment applies to figures, tables, definitions, etc. If in doubt on how to make the references, copy the style in the template text.}