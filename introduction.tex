\section{Introduction}\label{sc:introduction}
Cyber-physical systems (CPS) are becoming ever more sophisticated, while market pressure shortens the available development time. One of the tools used to manage the increasing complexity of such systems is co-simulation since it addresses their various parts of heterogeneous nature. Co-simulation is a technique to combine multiple black-box simulation units to simulate/compute the behavior of the combined models as a discrete trace\cite{Kubler2000}. The simulation units, often developed independently from each other, are coupled using a master algorithm, also often developed independently, that communicates with each simulation unit via its interface. This interface comprises functions for setting/getting inputs/outputs, and computing the associated model behavior over a given time interval. \\
The Functional Mock-up Interface (FMI) standard \cite{Blochwitz2012, fmi_2019} is such an interface prescribing how to communicate with each simulation unit. The interface is used to connect different simulation units (called Functional Mock-up Units or FMUs) and exchange values between them and make them progress in time. \\

A typical co-simulation consists of three phases: Initialization, simulation, and teardown. This work concentrates on the first of these phases - the initialization phase. The FMI specification specifies criteria for how a single FMU shall be initialized. However, the FMI standard is not concerned with how a connected system of multiple FMUs should be correctly initialized as a whole. 
The way a system of multiple FMUs should be initialized and interacted with depends on each FMUs implementation and interconnections to other FMUs \cite{gomes_lucio_vangheluwe_2019}, since these place precedence constraints between the FMU variables. The precedence constraints between the variables can introduce algebraic loops, which places particular requirements on the initialization order since the algebraic loops require a particular initialization strategy to be applied to calculate the initial values of the variables in the algebraic loop\cite{Bastian2011a}. The order of initialization is vital for the correctness of the co-simulation \cite{Thule2018} because it ensures a variable is never read before it is set like the classical \textit{readersâ€“writers problem} and to make sure that all initial values have stabilized at the start of the simulation. 

\noindent Algebraic loops occur whenever there is an interconnected FMU variable that indirectly depends on itself. Algebraic loops introduce specific challenges in the co-simulation, and studies have shown that neglecting a loop can lead to a prohibitively high error in the co-simulation \cite{Kubler2000}. Other approaches for the generation of co-simulation algorithms have avoided co-simulation scenarios containing algebraic loops since their presence reduces the chance of obtaining a valid co-simulation result\cite{Amalio2016CheckingCo-simulation, BromanCompositionCo-Simulation}. This choice is motivated by the fact that not all co-simulation scenarios containing algebraic loops are valid since some algebraic loops have a divergent nature. However, experience has shown that valid co-simulation scenarios containing algebraic loops exist, and a well-established co-simulation framework should be able to handle these scenarios. 

\textit{Contribution:} This paper describes an approach for calculating the initialization order of an FMI-based co-simulation in linear time of the number of interconnected variables. The approach complies with the semantics of FMI and support the initialization of algebraic loops between interconnected FMU variables and identifies divergent co-simulation scenarios. The approach does not put any constraints on choosing a master algorithm that should be used to carry out the simulation. This means that the approach is suitable to combine with well-established master algorithms like Gauss-Seidel and Jacobian \cite{Palensky2017}. The approach has been realized as a plugin to the co-simulation framework called INTO-CPS Maestro 2 (Maestro 2). \\
The realized plugin has been tested for various co-simulation scenarios and compared to an existing \textit{Initializer} that has been validated through academic and industrial applications. 
Furthermore, the calculated initialization order is systematically verified by an established co-simulation Algorithm Generator and Verifier by Gomes et al. implemented in Prolog \cite{gomes_lucio_vangheluwe_2019}. \\

\textit{Structure:} The paper is structured as follows: Section \ref{sc:background} gives a brief background of the formalization of FMUs and Maestro 2. Section \ref{sc:initilization} describes the approach taken to calculate the initialization order. This is followed by section \ref{sc:implementation}, where the realization of the approach is presented. Finally, section \ref{sc:summary} provides concluding remarks and describes future work.