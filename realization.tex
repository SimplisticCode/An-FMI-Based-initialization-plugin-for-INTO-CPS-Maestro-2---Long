\section{Realization of a Maestro 2 Plugin}\label{sc:implementation}
The presented approach has been realized as a Maestro 2 expansion plugin that generates the \textit{Initialization}-phase of a co-simulation specification expressed in MaBL. The plugin calculates the MaBL-specification based on the FMUs of a co-simulation scenario and a specific plugin-configuration to let the user supply the initial values of FMU parameters and fine-tune the initialization of the system. The plugin can calculate a correct initialization specification if the co-simulation scenario adheres to the behavior dictated by the definition given in \cref{def:convergence} meaning all algebraic loops in the scenario convergences within a finite number of iterations.

The plugin optimizes the initialization order by grouping operations that can be executed in \textit{parallel} to take advantage of FMI's ability to \textit{set} or \textit{get} multiple variables of a single FMU in bulk. The criteria for this optimization is defined in \cref{def:optimization}. 
The developed plugin has been tested on numerous co-simulation scenarios from the INTO-CPS universe\cite{Maestro} and compared with the existing \textit{Initializer} of Maestro. The plugin has been tested as a part of the complete Maestro 2 pipeline. 

\subsection{Realization of the Topological Sorting}
The topological sorting algorithm (Tarjan's Algorithm) is implemented in Scala\cite{Scala}, an object-oriented programming language incorporating many features from the functional programming paradigm. The motivation for choosing Scala\cite{Scala} is its relation to JVM and the connection to Slang and the Sireum framework\cite{inbook}. Slang (Sireum Language) is a programming language based on Scala, developed at Kansas State University (KSU), to develop and reason about critical software systems. Sireum is a framework for performing programming language analysis, reasoning, and verification of CPS also developed at KSU. Logika is one of the tools in the Sireum framework used for performing automated formal verification of a piece of Slang code using the theorem prover Z3\cite{Z3prover2020Sep}.
The connection of the implementation to Slang and Logika will be investigated in future work. The plan is to use the Logika framework to formally verifying the plugin. This will also be used to explore how Slang's contract-based nature can be used to obtain more reliable results of co-simulations. Tarjan's algorithm returns a topological order of strongly connected components. The returned order is the initialization order, where the non-trivial strongly connected components denote an algebraic loop requiring a particular initialization strategy. 

\subsection{Verification of the Initialization Order}
The plugin is verified using several methods. The plugin approach is established using traditional proof methods, and the plugin has been practically verified against an established co-simulation step verifier. Gomes et al. have verified the approach in \cite{gomes_lucio_vangheluwe_2019}; they proved the correctness of using the topological order of a dependency graph of the interconnected FMU-variables as the order of the operations in a co-simulation step (both the initialization procedure and an arbitrary step). Gomes et al. \cite{gomes_lucio_vangheluwe_2019} used a graph of FMU-operations (\textit{Set, Get, doStep}) in their proof instead of interconnected FMU-variables, which is the approach of this paper. The simplification of using the interconnected FMU-variables is valid and preserves the properties proved by Gomes et al. since this approach only considers the initialization phase of a co-simulation. This makes it possible to omit all the \textit{doStep} nodes from Gomes et al.'s graph, eventually ending up with a graph similar to the initialization graph described in \cref{def:initialization_graph}. 
This approach is a subgraph of the graph by Gomes et al.\cite{gomes_lucio_vangheluwe_2019}, which allows their proof to be modified to the approach presented in this paper.

\subsubsection{Practical Verification against an Established Verifier} 
Gomes et al.'s \cite{gomes_lucio_vangheluwe_2019} main contribution is a Prolog implementation of the principles for a valid FMI based co-simulation step \footnote{\url{http://msdl.cs.mcgill.ca/people/claudio/projs/PrologCosimGeneration.zip}.}. Gomes et al. use the Prolog implementation in their research to verify their approach for generating different co-simulation algorithms. The Prolog realization encapsulates all the rules of a valid co-simulation step (both master-algorithm and an initialization algorithm). 
The Initializer includes an integration to the Prolog Verifier. The integration is a Java program based on JIProlog \cite{JIProlog} - a library that allows calling Prolog predicates directly from Java. The integration is used to check the initialization order against the rules in the Prolog database. The integration performs all the necessary transformations of the dependency graph (see definition \ref{def:initialization_graph}) used in the Maestro plugin to a graph of FMU operations used in the Prolog database. The transformation is based on the definitions \ref{def:getout} and \ref{def:setin}. The integration has been realized to systematically verify the calculated initialization order's correctness against an established and recognized co-simulation Algorithm Verifier. 
The Prolog implementation does support co-simulation scenarios containing algebraic loop, so these scenarios are not tested against the Prolog database.
