\section{Realization of a Maestro 2 Plugin}\label{sc:implementation}
This approach has been realized as a Maestro 2 plugin that generates the \textit{Initialization}-phase of a co-simulation specification expressed in MaBL. It calculates the specification based on a list of FMU-components of a co-simulation scenario, and a specific plugin-configuration to let the user supply initial values of FMU variables with $causality=parameter$. A correction initialization specification can be calculated by the plugin if the co-simulation scenario is adhering to the behavior dictated by definition given in \ref{def:convergence}.

The plugin optimizes the initialization order by grouping operations that can be executed in \textit{parallel} to take advantage of FMI's ability to \textit{set} or \textit{get} multiple variables in bulk from the same FMU. The criteria for this optimization is defined in definition \ref{def:optimization}. 
The developed plugin has been tested on numerous co-simulation examples from the INTO-CPS universe\cite{Maestro} and compared with the existing \textit{Initializer} of Maestro. The plugin has been tested in the whole Maestro 2 pipeline to practically verify that it can be used in a co-simulation where the generated initialization procedure is integrated as a part of a complete co-simulation to verify the initialization procedure's integration with a master algorithm.

\subsection{Realization of the Topological Sorting}
The topological sorting algorithm (Tarjan's Algorithm) was implemented in Scala. The motivation for choosing Scala is its relation to JVM and the connection to Slang and the Logika framework\cite{inbook}. The connection to Slang and Logika will be investigated in the future. The Logika framework will be used to formally verify the implemented plugin and be used to explore how the contract-based nature of Slang can be used to obtain more reliable results of co-simulations. The topological sorting returns a topological order of strongly connected components. This order is the order of initialization, where the elements containing more than a single element denotes an algebraic loop that requires a particular initialization strategy. 

\subsection{Verification of the Initialization Order}
The realized plugin has been verified in several ways using traditional proof methods and practical verification against an established co-simulation Verifier. The approach behind the plugin has been verified by Gomes et al. that in \cite{gomes_lucio_vangheluwe_2019} proved the correctness of using the topological order of a dependency graph of the interconnected variables to generate for the order of the operations that need to be performed in a co-simulation step (both the initialization procedure and an arbitrary step). Gomes et al. used a graph based on FMU-operations (\textit{Set, Get, doStep}) instead of interconnected variables, which is the approach described in this paper. The simplification of using the interconnected variables is valid since this approach only cares about initialization and, therefore, does not need to care about the time of each FMU. This does that we can omit all the \textit{doStep} nodes, it means that each interconnected variable can only perform one of the two operations \textit{get} or \textit{set} as described by the definitions \ref{def:getout} and \ref{def:setin}.
This approach does, therefore, end up with a subgraph of the graph by Gomes et al. The proof from \cite{gomes_lucio_vangheluwe_2019} can trivially be modified to the graph/approach presented in this paper.

\subsubsection{Practical verification against a Verifier} 
Gomes et al.'s main contribution is an implementation of the criteria for a valid FMI based co-simulation in Prolog freely available to be used in other projects\footnote{\url{}}. The Prolog implementation was used in their research to formally verify their proposed approach for the generation of co-simulation algorithms. The realization encapsulates all the rules of a valid master-algorithm and an initialization algorithm. As a part of this work, an integration from the developed plugin has been realized to interact with the Prolog Verifier. This integration has been realized to verify the correctness of the calculated initialization order against an established and recognized co-simulation Algorithm Generator and Verifier. The integration works by querying the Prolog database with a co-simulation environment and a calculated initialization to verify the order's correctness. The integration requires a transformation of the dependency graph (see definition \ref{def:initialization_graph}) used in the plugin to a graph of FMU operations. This transformation is based on the definitions \ref{def:getout} and \ref{def:setin}. The described verification integration is not utilized if the graph contains algebraic loops since the Prolog database does not support these scenarios.

The Prolog code can generate an initialization order, but this functionality has not been used for several reasons. The main reason for not creating the initialization order using the Prolog code is based on performance considerations. The approach taken in this paper does also identifies the strongly connected components and performs a particular initialization strategy of these.