\section{Realization of a Maestro 2 Plugin}\label{sc:implementation}
This approach has been realized as a Maestro 2 plugin that generates the \textit{Initialization}-phase of a co-simulation specification expressed in MaBL. It calculates the specification based on a list of FMU-components of a co-simulation scenario, and a specific plugin-configuration to let the user supply initial values of FMU variables with $causality=parameter$. A correction initialization specification can be calculated by the plugin if the co-simulation scenario is adhering to the behavior dictated by definition given in \ref{def:convergence}.

The plugin optimizes the initialization order by grouping operations that can be executed in \textit{parallel} to take advantage of FMI's ability to \textit{set} or \textit{get} multiple variables in bulk from the same FMU. The criteria for this optimization is defined in definition \ref{def:optimization}. 
The developed plugin has been tested on numerous co-simulation examples from the INTO-CPS universe\cite{Maestro} and compared with the existing \textit{Initializer} of Maestro. The plugin has been tested in the whole Maestro 2 pipeline to practically verify that it can be used in a co-simulation where the generated initialization procedure is integrated as a part of a complete co-simulation to verify the initialization procedure's integration with a master algorithm.

\subsection{Realization of the Topological Sorting}
The topological sorting algorithm (Tarjan's Algorithm) is implemented in Scala. The motivation for choosing Scala is its relation to JVM and the connection to Slang and the Logika framework\cite{inbook}. The connection to Slang and Logika will be investigated in the future. The Logika framework will be used to formally verify the implemented plugin and be used to explore how the contract-based nature of Slang can be used to obtain more reliable results of co-simulations. The topological sorting returns a topological order of strongly connected components. This order is the order of initialization, where the elements containing more than a single element denotes an algebraic loop that requires a particular initialization strategy. 

\subsection{Verification of the Initialization Order}
The realized plugin is verified in several ways using traditional proof methods and practical verification against an established co-simulation Verifier. The approach behind the plugin has been verified by Gomes et al. that in \cite{gomes_lucio_vangheluwe_2019} proved the correctness of using the topological order of a dependency graph of the interconnected variables to generate for the order of the operations that need to be performed in a co-simulation step (both the initialization procedure and an arbitrary step). Gomes et al. used a graph based on FMU-operations (\textit{Set, Get, doStep}) instead of interconnected variables, which is the approach described in this paper. The simplification of using the interconnected variables is valid since this approach only cares about initialization and, therefore, does not need to care about the time of each FMU. This does that we can omit all the \textit{doStep} nodes, it means that each interconnected variable can only perform one of the two operations \textit{get} or \textit{set} as described by the definitions \ref{def:getout} and \ref{def:setin}.
This approach does, therefore, end up with a subgraph of the graph by Gomes et al. The proof from \cite{gomes_lucio_vangheluwe_2019} can trivially be modified to the graph/approach presented in this paper.

\subsubsection{Practical verification against a Verifier} 
Gomes et al.'s main contribution is an implementation of the criteria for a valid FMI based co-simulation formulated in Prolog freely available to be used in other projects\footnote{\url{http://msdl.cs.mcgill.ca/people/claudio/projs/PrologCosimGeneration.zip}}. The Prolog implementation was used in their research to verify their approach for generating co-simulation algorithms formally. The Prolog realization encapsulates all the rules of a valid co-simulation step (both master-algorithm and an initialization algorithm). 
This work includes an integration from the developed plugin to the Prolog Verifier. The integration has been realized to systematically verify the correctness of the calculated initialization order against an established and recognized co-simulation Algorithm Verifier. The integration queries the Prolog database with a co-simulation environment and a calculated initialization order to verify the order's correctness. The integration performs all the necessary transformations of the dependency graph (see definition \ref{def:initialization_graph}) used in the Maestro plugin to a graph of FMU operations used in the Prolog database. The transformation is based on the definitions \ref{def:getout} and \ref{def:setin}. The Prolog integration is not applied if the graph contains algebraic loops since the Prolog database does not support these scenarios.

The Prolog code is capable of generating a valid initialization order, but this functionality is not used for several reasons. The main reasons are based on performance considerations and the desire to handle the initialization of co-simulation scenarios containing strongly connected components.