\section{Realization of a Maestro 2 Plugin}\label{sc:implementation}
The presented approach has been realized as a Maestro 2 expansion plugin that generates the \textit{Initialization}-phase of a co-simulation specification expressed in MaBL. It calculates the MABL-specification based on a list of FMU-components of a co-simulation scenario and a specific plugin-configuration to let the user supply the initial values of  FMU parameters and fine-tune the initialization of the system. The plugin can calculate a correct initialization specification if the co-simulation scenario adheres to the behavior dictated by the definition given in \cref{def:convergence} that all algebraic loops in the scenario convergences within a finite number of iterations.

The plugin optimizes the initialization order by grouping operations that can be executed in \textit{parallel} to take advantage of FMI's ability to \textit{set} or \textit{get} multiple variables of the same FMU in bulk. The criteria for this optimization is defined in \cref{def:optimization}. 
The developed plugin has been tested on numerous co-simulation examples from the INTO-CPS universe\cite{Maestro} and compared with the existing \textit{Initializer} of Maestro. The plugin has been tested as a part of the Maestro 2 pipeline. 

\subsection{Realization of the Topological Sorting}
The topological sorting algorithm (Tarjan's Algorithm) is implemented in Scala\cite{Scala}, an object-oriented programming language incorporating many features from the functional programming paradigm. The motivation for choosing Scala is its relation to JVM and the connection to Slang and the Sireum framework\cite{inbook}. Slang (Sireum Language)is a programming language based on Scala and developed at Kansas State University (KSU) to develop and reason about critical software systems. Sireum is a framework for performing programming language analysis, reasoning, and verification of CPS also developed at KSU. The tool in the Sireum framework for performing automated verification analysis of a piece of Slang code is called Logika. 
The connection to Slang and Logika will be investigated in the future. The Logika framework will be used to formally verify the implemented plugin and be used to explore how the contract-based nature of Slang can be used to obtain more reliable results of co-simulations. The topological sorting returns an order of strongly connected components. This order is the initialization order, where the elements containing more than a single element denotes an algebraic loop that requires a particular initialization strategy. 

\subsection{Verification of the Initialization Order}
The plugin is verified in several ways. The approach is established using traditional proof methods, and the plugin has been practically verified against an established co-simulation step verifier. Gomes et al. has verified the approach in \cite{gomes_lucio_vangheluwe_2019} they proved the correctness of using the topological order of a dependency graph of the interconnected variables as the order of the operations that need to be performed in a co-simulation step (both the initialization procedure and an arbitrary step). Gomes et al. \cite{gomes_lucio_vangheluwe_2019} used a graph based on FMU-operations (\textit{Set, Get, doStep}) in their proof instead of interconnected variables, which is the approach described in this paper. The simplification of using the interconnected variables is valid and preserves the properties proved by Gomes et al. since this approach only considers the initialization phase of a co-simulation, making the timing aspect irrelevant. Due to this fact all the \textit{doStep} nodes can be omitted, meaning each interconnected variable can only perform one of the following two operations \textit{get} or \textit{set} as described by the \cref{def:getout,def:setin}.
This approach, therefore, ends up with a subgraph of the graph by Gomes et al.\cite{gomes_lucio_vangheluwe_2019}, which allows the proof from \cite{gomes_lucio_vangheluwe_2019} to be modified to the approach presented in this paper trivially.

\subsubsection{Practical verification against an established Verifier} 
Gomes et al.'s \cite{gomes_lucio_vangheluwe_2019} main contribution is a Prolog implementation of the principles for a valid FMI based co-simulation scenario. The Prolog program is freely available to be used in other projects\footnote{\url{http://msdl.cs.mcgill.ca/people/claudio/projs/PrologCosimGeneration.zip}}. The Prolog implementation was used in their research to verify their approach for generating co-simulation algorithms formally. The Prolog realization encapsulates all the rules of a valid co-simulation step (both master-algorithm and an initialization algorithm). 
The realized Initializer includes an integration from the developed plugin to the Prolog Verifier. The integration is a Java program based on JIProlog \cite{JIProlog} - a library that allows calling Prolog predicates directly from Java. The integration queries the Prolog database by Gomes et al. with a co-simulation scenario and a calculated initialization order to verify the order's correctness. The integration performs all the necessary transformations of the dependency graph (see definition \ref{def:initialization_graph}) used in the Maestro plugin to a graph of FMU operations used in the Prolog database. The transformation is based on the definitions \ref{def:getout} and \ref{def:setin}. The integration has been realized to systematically verify the calculated initialization order's correctness against an established and recognized co-simulation Algorithm Verifier. 
In co-simulation scenarios containing algebraic loop, the integration to the Prolog implementation is bypassed since Gomes et al. 's Prolog program does not support these scenarios.
